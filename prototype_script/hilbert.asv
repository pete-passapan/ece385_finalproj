%% Load your real WAV file
[raw_speech, raw_fs] = audioread('sample1.wav');

% If stereo, convert to mono
if size(raw_speech,2) == 2
    raw_speech = mean(raw_speech,2);
end

% Target sample rate
target_fs = 44000; % You can change this!

% Resample if needed
if raw_fs ~= target_fs
    disp(['Resampling from ', num2str(raw_fs), ' Hz to ', num2str(target_fs), ' Hz...']);
    speech = resample(raw_speech, target_fs, raw_fs);
else
    speech = raw_speech;
end

speech = speech(:).';   % Force row vector
speech = speech / max(abs(speech)); % Normalize

% Limit to 1 second (or pad if needed)
if length(speech) > target_fs
    speech = speech(1:round(5* target_fs));
else
    speech = [speech, zeros(1, round(1 * target_fs) - length(speech))];
end

t = (0:length(speech)-1) / target_fs;

% % ðŸŽ§ Play your input sound
% disp('Playing original (or resampled) audio...');
% sound(speech, target_fs);
% pause(length(speech)/target_fs + 0.5);

%% Define Mel-like Bandpass Filters
n_filters = 15;
lo = 50;
hi = 8000;
band_edges = logspace(log10(lo), log10(hi), n_filters+1);
band_centers = sqrt(band_edges(1:end-1) .* band_edges(2:end));

filters = cell(n_filters,1);
for i = 1:n_filters
    filters{i} = designfilt('bandpassiir', ...
        'FilterOrder', 4, ...
        'HalfPowerFrequency1', band_edges(i), ...
        'HalfPowerFrequency2', band_edges(i+1), ...
        'SampleRate', target_fs, ...
        'DesignMethod', 'butter');
end

%% FIR Hilbert Transformer for Envelope Detection
N = 31; % (or increase to 127 for sharper edges)
fs = 44000;

h_hilbert = firpm(N-1, [0.05 0.95], [1 1], 'hilbert');
fixed_pt = size(round(vpa(h_hilbert).*2^14));


%% Lowpass Filter for Envelope Smoothing
lpFilt = designfilt('lowpassiir', ...
    'FilterOrder', 2, ...
    'HalfPowerFrequency', 50, ...
    'SampleRate', target_fs, ...
    'DesignMethod', 'butter');

%% Extract Envelopes from Each Band
use_hilbert = false;

envelopes = cell(n_filters,1);
for i = 1:n_filters
    band_out = filter(filters{i}, speech);
    band_out = band_out(:).'; % force row vector

    if use_hilbert
        % Hilbert-based envelope
        I = [zeros(1, (N-1)/2), band_out(1:end-(N-1)/2)]; % Delay in-phase
        Q = filter(h_hilbert, 1, band_out);               % Hilbert transform
        env = abs(I) + abs(Q);                            % Envelope magnitude
    else
        % Rectifier-based envelope
        env = abs(band_out);
    end

    env_smoothed = filter(lpFilt, env);  % Envelope smoothing
    envelopes{i} = env_smoothed;
end

%% Load and Loop Carrier Snippet (1 ms)

[carrier_sample, carrier_fs] = audioread('sample8.wav');

% Convert to mono
if size(carrier_sample, 2) > 1
    carrier_sample = mean(carrier_sample, 2);
end

% Resample if needed
if carrier_fs ~= target_fs
    carrier_sample = resample(carrier_sample, target_fs, carrier_fs);
end

% Extract a 1 ms snippet
snippet_length = round(target_fs * 0.09173); % 1 ms at target_fs
if length(carrier_sample) < snippet_length
    error('Carrier file too short for 1 ms snippet.');
end
carrier_snippet = carrier_sample(10000:(10000+snippet_length-1));

% Repeat to match the length of the speech
num_repeats = ceil(length(speech) / snippet_length);
carrier_looped = repmat(carrier_snippet, num_repeats, 1);
carrier_looped = carrier_looped(1:length(speech));  % Trim to match speech length

% Normalize
carrier_sample = carrier_looped / max(abs(carrier_looped));


% ðŸŽ§ Optional: Listen to carrier alone
% sound(carrier_sample, target_fs);



%% Multiply Envelopes Ã— Carrier Bands
modulated = zeros(length(t), 1);

for i = 1:n_filters
    env = envelopes{i};        % speech envelope in this band
    carrier_band = carrier_bands{i}; % carrier band

    mod_band = env(:) .* carrier_band(:);
    modulated = modulated + mod_band;
end

% Normalize
vocoded = modulated / max(abs(modulated));

%% Listen
disp('Playing vocoded sound...');
sound(vocoded, fs);
% 
% figure;
% plot(t, vocoded);
% title('Vocoded output (1 global carrier)');
% xlabel('Time [s]');
% ylabel('Amplitude');
% xlim([0 0.5]);
% grid on;


